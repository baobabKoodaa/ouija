<!DOCTYPE html>
<html>

<head>
    <title>Ouija Online - A horror experience</title>
    <style>
        * {
            box-sizing: border-box;
        }

        p,
        pre {
            margin: 0;
            padding: 0;
        }

        html {
            height: 100%;
        }

        body {
            /* Using 32px margin around body to avoid funny business with cursor near the edges of window */
            margin: 32px;
            height: calc(100% - 64px);
            overflow-y: hidden;
            overflow-x: hidden;
            padding: 0;
            background: black;
        }

        @font-face {
            font-family: 'Feral';
            src: url('assets/Feral-Regular.woff2') format('woff2'),
                url('assets/Feral-Regular.woff') format('woff');
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }

        @font-face {
            font-family: 'Carnivalee Freakshow';
            src: url('assets/CarnivaleeFreakshow.woff2') format('woff2'),
                url('assets/CarnivaleeFreakshow.woff') format('woff');
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }

        @font-face {
            font-family: 'Kingthings Trypewriter 2';
            src: url('assets/KingthingsTrypewriter2.woff2') format('woff2'),
                url('assets/KingthingsTrypewriter2.woff') format('woff');
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }

        #mobileWarning {
            display: none;
            background-color: white;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1100;
        }

        #consentPopup {
            display: none;
            z-index: 994;
            border: 1px solid black;
            border-radius: 10px;
            background-color: #fbedc8;
            color: black;
            font-size: 2vw;
            position: absolute;
            left: 50%;
            top: 50%;
            width: 80%;
            -webkit-transform: translate(-50%, -50%);
            transform: translate(-50%, -50%);
            padding: 1.5vw;
            cursor: none;
            transition: opacity 3s ease-in;
            opacity: 1.0;
            font-family: 'Carnivalee Freakshow';
            background-color: #fbedc8;
            background-image: url("data:image/svg+xml,%3Csvg width='180' height='180' viewBox='0 0 180 180' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M82.42 180h-1.415L0 98.995v-2.827L6.167 90 0 83.833V81.004L81.005 0h2.827L90 6.167 96.167 0H98.996L180 81.005v2.827L173.833 90 180 96.167V98.996L98.995 180h-2.827L90 173.833 83.833 180H82.42zm0-1.414L1.413 97.58 8.994 90l-7.58-7.58L82.42 1.413 90 8.994l7.58-7.58 81.006 81.005-7.58 7.58 7.58 7.58-81.005 81.006-7.58-7.58-7.58 7.58zM175.196 0h-25.832c1.033 2.924 2.616 5.59 4.625 7.868C152.145 9.682 151 12.208 151 15c0 5.523 4.477 10 10 10 1.657 0 3 1.343 3 3v4h16V0h-4.803c.51.883.803 1.907.803 3 0 3.314-2.686 6-6 6s-6-2.686-6-6c0-1.093.292-2.117.803-3h10.394-13.685C161.18.938 161 1.948 161 3v4c-4.418 0-8 3.582-8 8s3.582 8 8 8c2.76 0 5 2.24 5 5v2h4v-4h2v4h4v-4h2v4h2V0h-4.803zm-15.783 0c-.27.954-.414 1.96-.414 3v2.2c-1.25.254-2.414.74-3.447 1.412-1.716-1.93-3.098-4.164-4.054-6.612h7.914zM180 17h-3l2.143-10H180v10zm-30.635 163c-.884-2.502-1.365-5.195-1.365-8 0-13.255 10.748-24 23.99-24H180v32h-30.635zm12.147 0c.5-1.416 1.345-2.67 2.434-3.66l-1.345-1.48c-1.498 1.364-2.62 3.136-3.186 5.14H151.5c-.97-2.48-1.5-5.177-1.5-8 0-12.15 9.84-22 22-22h8v30h-18.488zm13.685 0c-1.037-1.793-2.976-3-5.197-3-2.22 0-4.16 1.207-5.197 3h10.394zM0 148h8.01C21.26 148 32 158.742 32 172c0 2.805-.48 5.498-1.366 8H0v-32zm0 2h8c12.15 0 22 9.847 22 22 0 2.822-.53 5.52-1.5 8h-7.914c-.567-2.004-1.688-3.776-3.187-5.14l-1.346 1.48c1.09.99 1.933 2.244 2.434 3.66H0v-30zm15.197 30c-1.037-1.793-2.976-3-5.197-3-2.22 0-4.16 1.207-5.197 3h10.394zM0 32h16v-4c0-1.657 1.343-3 3-3 5.523 0 10-4.477 10-10 0-2.794-1.145-5.32-2.992-7.134C28.018 5.586 29.6 2.924 30.634 0H0v32zm0-2h2v-4h2v4h4v-4h2v4h4v-2c0-2.76 2.24-5 5-5 4.418 0 8-3.582 8-8s-3.582-8-8-8V3c0-1.052-.18-2.062-.512-3H0v30zM28.5 0c-.954 2.448-2.335 4.683-4.05 6.613-1.035-.672-2.2-1.16-3.45-1.413V3c0-1.04-.144-2.046-.414-3H28.5zM0 17h3L.857 7H0v10zM15.197 0c.51.883.803 1.907.803 3 0 3.314-2.686 6-6 6S4 6.314 4 3c0-1.093.292-2.117.803-3h10.394zM109 115c-1.657 0-3 1.343-3 3v4H74v-4c0-1.657-1.343-3-3-3-5.523 0-10-4.477-10-10 0-2.793 1.145-5.318 2.99-7.132C60.262 93.638 58 88.084 58 82c0-13.255 10.748-24 23.99-24h16.02C111.26 58 122 68.742 122 82c0 6.082-2.263 11.636-5.992 15.866C117.855 99.68 119 102.206 119 105c0 5.523-4.477 10-10 10zm0-2c-2.76 0-5 2.24-5 5v2h-4v-4h-2v4h-4v-4h-2v4h-4v-4h-2v4h-4v-4h-2v4h-4v-2c0-2.76-2.24-5-5-5-4.418 0-8-3.582-8-8s3.582-8 8-8v-4c0-2.64 1.136-5.013 2.946-6.66L72.6 84.86C70.39 86.874 69 89.775 69 93v2.2c-1.25.254-2.414.74-3.447 1.412C62.098 92.727 60 87.61 60 82c0-12.15 9.84-22 22-22h16c12.15 0 22 9.847 22 22 0 5.61-2.097 10.728-5.55 14.613-1.035-.672-2.2-1.16-3.45-1.413V93c0-3.226-1.39-6.127-3.6-8.14l-1.346 1.48C107.864 87.987 109 90.36 109 93v4c4.418 0 8 3.582 8 8s-3.582 8-8 8zM90.857 97L93 107h-6l2.143-10h1.714zM80 99c3.314 0 6-2.686 6-6s-2.686-6-6-6-6 2.686-6 6 2.686 6 6 6zm20 0c3.314 0 6-2.686 6-6s-2.686-6-6-6-6 2.686-6 6 2.686 6 6 6z' fill='%23d9c99f' fill-opacity='0.24' fill-rule='evenodd'/%3E%3C/svg%3E");
        }

        #consentHoverboard {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 995;
        }

        #consentButtonsContainer {
            display: flex;
            flex-direction: row;
            width: 100%;
            text-align: center;
            margin-top: 1em;
            z-index: 996;
        }

        #consentYes,
        #consentNo {
            border: 1px solid black;
            border-radius: 10px;
            padding: 0.5vw;
            width: 100%;
            flex-grow: 1;
            z-index: 996;
        }

        #consentYes {
            background-color: #ffb700;
            transition: 0.5s;
        }

        #consentNo {
            background-color: #ebebeb;
            margin-left: 1.5vw;
            transition: 0.5s;
        }

        #consentYes:hover {
            box-shadow: 0 0 15px #ffb700;
            text-shadow: 0 0 7px #5c533b;
        }

        #consentNo:hover {
            color: gray;
        }

        #bg {
            position: relative;
            width: 100%;
            height: 100%;
            cursor: none;
            z-index: 9;
        }

        @keyframes board-glow {
            0% {
                box-shadow: 0 0 50px #d35400;
            }

            100% {
                box-shadow: 0 0 50px 20px #d35400;
            }
        }

        @keyframes scale-up-down {
            0% {
                transform: scale(1.0)
            }

            50% {
                transform: scale(1.1)
            }

            100% {
                transform: scale(1.0)
            }
        }

        .one-time-bump {
            animation-name: scale-up-down;
            animation-iteration-count: 1;
            animation-duration: 0.5s;
        }

        #boardContainer {
            position: absolute;
            width: 50%;
            left: 50%;
            top: 50%;
            -webkit-transform: translate(-50%, -50%);
            transform: translate(-50%, -50%);
            z-index: 10;
        }

        #board {
            position: relative;
            width: 100%;
            border-radius: 10%;
            z-index: 11;
            animation-name: board-glow;
            animation-iteration-count: infinite;
            animation-duration: 2s;
            animation-timing-function: ease-in-out;
            animation-direction: alternate;
        }

        #hoverBoard {
            position: absolute;
            top: 0%;
            left: 0%;
            width: 100%;
            height: 100%;
            z-index: 12;
            cursor: none;
        }

        #planchette,
        #planchetteHelper {
            position: absolute;
            top: 44%;
            left: 40.5%;
            width: 18%;
            transform: rotate(130deg);
            cursor: none;
        }

        #planchette {
            z-index: 15;
            transition: filter 1.5s ease-in;
            /* TODO ease-in-out? */
        }

        .planchette-no-glow {
            filter: drop-shadow(5px 5px 5px #222);
        }

        .planchette-active-glow {
            filter: drop-shadow(5px 5px 5px rgb(255, 198, 198));
            /** filter: drop-shadow(5px 5px 5px '#fce'); */
        }

        #planchetteHelper {
            z-index: 16;
            opacity: 0;
            /* Can't use visibility:hidden because need mouse movements to trigger events */
        }

        #magnifying-glass {
            background-image: url('assets/ouija_bg.jpg');
            background-repeat: no-repeat;
            position: absolute;
            border-radius: 50%;
            cursor: none;
            visibility: hidden;
            z-index: 14;
        }

        #magnifying-glass-surface {
            background-color: #563e23;
            opacity: 0.4;
            width: 100%;
            height: 100%;
        }

        #spiritMessageContainer {
            position: absolute;
            top: -13%;
            pointer-events: none;

            /* Centering */
            left: -50%;
            width: 100vw;
            text-align: center;
            letter-spacing: 3vw;
            text-indent: 3vw;

            /* Styling */
            font-size: 2vw;
            color: #fff;
            text-shadow: 0 0 5px #d35400;
            text-transform: uppercase;
            font-family: 'Feral';

        }

        #spiritMessageContainer::before,
        #spiritMessageContainer::after {
            content: attr(data-text);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }

        #spiritMessageContainer::before {
            color: #f3ba39;
            animation: glitch-effect 6s infinite;
        }

        #spiritMessageContainer::after {
            color: #f3ba39;
            animation: glitch-effect 4s infinite;
        }

        /* Glitch effect popularized by Tiktok, code from https://amazingcss.com/glitch-text-effect-like-tiktok/ */
        @keyframes glitch-effect {
            0% {
                left: -4px;
                top: -4px;
            }

            25% {
                left: 4px;
                top: 0px;
            }

            50% {
                left: -2px;
                top: 4px;
            }

            75% {
                left: 2px;
                top: -2px;
            }

            100% {
                left: 0px;
                top: -4px;
            }
        }

        #userMessageContainer {
            position: absolute;
            left: -50%;
            bottom: -13%;
            display: flex;
            justify-content: center;
            width: 100vw;
            height: 3vh;
            pointer-events: none;
        }

        #userMessagePre {
            position: absolute;
            height: 3vh;
            line-height: 3vh;
            font-size: 2vw;
            letter-spacing: 0.8vw;
            text-transform: uppercase;
            font-family: 'Kingthings Trypewriter 2', 'Courier New', 'Courier', monospace;
            color: #fff;
            transition: color 1.0s ease-out;
        }

        .blinking-caret {
            border-right: .15em solid #ff9900;
            animation: blink-caret .75s step-end infinite;
        }

        @keyframes blink-caret {

            from,
            to {
                border-color: transparent
            }

            50% {
                border-color: #ff9900;
            }
        }

        .orangey-text {
            color: #563e23 !important;
        }

        #cursor {
            position: absolute;
            top: 30%;
            left: 30%;
            height: 33px;
            /* height must be evenly divisible from 128px */
            visibility: hidden;
            pointer-events: none;
            z-index: 1000;
        }

        .unselectable {
            user-select: none;
            -moz-user-select: none;
            -khtml-user-select: none;
            -webkit-user-select: none;
            -o-user-select: none;
            -ms-user-select: none;

            user-drag: none;
            -webkit-user-drag: none;
        }

        @media only screen and (max-width: 760px) {
            .mobile-warning {
                display: block;
            }
        }
    </style>

    <script>

        // String literals
        const ON_PLANCHETTE = 'onPlanchette'
        const ON_USER_MESSAGE = 'onUserMessage'
        const ON_BUTTON = 'onButton'
        const RECORDING = 'recording'
        const SPEEDMODE = 'speedMode'
        const TURN_SPIRIT = 'turnSpirit'
        const TURN_USER = 'turnUser'
        const OUIJA_USER_ID = 'ouija-user-id'

        // Global state
        let waitingForConsent = false
        let draggingPlanchette = false
        let planchetteTransformX = 0 // In % relative to planchette's own width (to support browser resizing)
        let planchetteTransformY = 0 // In % relative to planchette's own width (to support browser resizing)
        let prevX = undefined
        let prevY = undefined
        let offsetX = 0 // In % relative to planchette's width (to support browser resizing consistently with planchetteHelper)
        let offsetY = 0 // In % relative to planchette's width (to support browser resizing consistently with planchetteHelper)
        let userMoveCount = 0
        let remainingGoals = ''
        let spiritMessage = ''
        let userMessage = ''
        let currentExchangeNumber = 0
        let turn = TURN_USER
        let debug = {}

        // Magnifier constants
        const MAG_ZOOM = 1.2
        const MAG_LEFT = 0.465
        const MAG_TOP = 0.58

        // Offset constants
        const SPIRIT_MAX_DIST = 60.0
        const SPIRIT_STOCHASTIC_STR = 0.6
        const SPIRIT_ACCEL_STR = 1.4
        const OFFSET_CANCELLATION_STR = 0.3
        const OFFSET_CANCELLATION_LOW_URGENCY = 0.3

        // Planchette drag limitations (board area)
        const HARD_Y_MAX = 80
        const HARD_Y_MIN = -160
        const HARD_X_MAX = 270
        const HARD_X_MIN = -255
        const SOFT_Y_MAX = HARD_Y_MAX - 10
        const SOFT_Y_MIN = HARD_Y_MIN - 10
        const SOFT_X_MAX = HARD_X_MAX - 10
        const SOFT_X_MIN = HARD_X_MIN - 10

        // User message constants
        USER_MESSAGE_MAX_LENGTH = 40

        // Goal constants. Coordinates are in % relative to planchette transform.
        const ALLOWED_CHARS = 'abcdefghijklmnopqrstuvwxyz1234567890'
        const CHAR_SELECT_MAX_DIST = 10
        const goalCoords = {
            "0": { "x": 96.57, "y": -0.67 },
            "1": { "x": -110.95, "y": -1.07 },
            "2": { "x": -92.67, "y": -0.27 },
            "3": { "x": -69.56, "y": -0.27 },
            "4": { "x": -45.9, "y": -0.27 },
            "5": { "x": -23.86, "y": -0.27 },
            "6": { "x": -1.28, "y": -0.67 },
            "7": { "x": 20.23, "y": -0.67 },
            "8": { "x": 42.27, "y": -0.27 },
            "9": { "x": 67.54, "y": -0.67 },
            "a": { "x": -159.6, "y": -58.17 },
            "b": { "x": -139.2, "y": -77.69 },
            "c": { "x": -115.5, "y": -91.63 },
            "d": { "x": -91.94, "y": -101.99 },
            "e": { "x": -64.52, "y": -110.36 },
            "f": { "x": -35.48, "y": -115.5 },
            "g": { "x": -6.57, "y": -116.62 },
            "h": { "x": 24.94, "y": -115.17 },
            "i": { "x": 52.9, "y": -111.67 },
            "j": { "x": 74.94, "y": -105.69 },
            "k": { "x": 105.05, "y": -94.14 },
            "l": { "x": 130.32, "y": -79.4 },
            "m": { "x": 152.9, "y": -63.06 },
            "n": { "x": -152.8, "y": -7.68 },
            "o": { "x": -136.2, "y": -22.82 },
            "p": { "x": -117.9, "y": -36.37 },
            "q": { "x": -94.81, "y": -47.92 },
            "r": { "x": -65.24, "y": -57.48 },
            "s": { "x": -36.75, "y": -63.46 },
            "t": { "x": -6.75, "y": -67.17 },
            "u": { "x": 24.53, "y": -65.21 },
            "v": { "x": 55.17, "y": -60.83 },
            "w": { "x": 86.36, "y": -51.67 },
            "x": { "x": 111.63, "y": -37.72 },
            "y": { "x": 134.21, "y": -24.18 },
            "z": { "x": 147.65, "y": -9.44 }
        }

        // Memoize some values to reduce reflows (improve performance).
        let boardWidth = 0
        let boardHeight = 0
        let boardTop = 0
        let boardLeft = 0
        let planchetteWidth = 0
        let planchetteHeight = 0
        let magSize = 0
        let windowWidth = 0
        let windowHeight = 0
        const resizeUpdates = function () {
            // Update memoized values
            const boardBounds = document.getElementById('boardContainer').getBoundingClientRect()
            boardTop = boardBounds.top
            boardLeft = boardBounds.left
            boardWidth = boardBounds.width
            boardHeight = boardBounds.height
            const planchette = document.getElementById('planchette')
            planchetteWidth = planchette.clientWidth
            planchetteHeight = planchette.clientHeight
            windowWidth = window.innerWidth
            windowHeight = window.innerHeight

            // Update magnifying glass
            const mag = document.getElementById('magnifying-glass')
            magSize = planchetteWidth * 0.40
            Object.assign(mag.style, {
                left: (100 * MAG_LEFT) + "%",
                top: (100 * MAG_TOP) + "%",
                width: magSize + 'px', // TODO %
                height: magSize + 'px', // TODO %
                backgroundSize: (MAG_ZOOM * 100 * boardWidth / magSize) + '% ' + (MAG_ZOOM * 100 * boardHeight / magSize) + '%',
                visibility: 'visible'
            })
            updateMagnifyingGlassPosition()

            // Fix edge case where user sees 2 cursors when using keyboard shortcut to resize browser
            cursor.style.visibility = "hidden";
        }
        // Call resizeUpdates after the first complete render and after each resize
        window.addEventListener('load', function (event) {
            resizeUpdates()
        });
        window.addEventListener('resize', function (event) {
            resizeUpdates()
        });

        const LOG_ENDPOINT = 'https://endpoint1.collection.eu.sumologic.com/receiver/v1/http/ZaVnC4dhaV0vBIvS0oahg-8LYhDkyFCtWZ2zZ_7NbP0x0PYd0DmEk2cLgA4DJlePqnHWB5KjcxPFudwdOmtop0b6isr9VgLeKHYmzJ6eSqkD0cyZ6FNQiQ=='
        const logToSumoLogic = function (message) {
            try {
                const augmentedMessage = `${window.localStorage.getItem(OUIJA_USER_ID)}:${Date.now()}:${using_GPT3 ? "GPT-3" : "Simple"}:${message}`
                fetch(`${LOG_ENDPOINT}?${augmentedMessage}`)
            } catch (ex) {
                console.log('Logging to Sumo Logic failed', ex)
            }
        }

        const paintCursorWithOffset = function (cursor, realX, realY) {
            let x = realX + offsetX * planchetteWidth / 100
            let y = realY + offsetY * planchetteHeight / 100
            cursor.style.top = (y - boardTop) + "px";
            cursor.style.left = (x - boardLeft) + "px";
        }

        const updateMagnifyingGlassPosition = function () {
            const mag = document.getElementById('magnifying-glass')
            const xMoveWithOffset = planchetteTransformX + offsetX
            const yMoveWithOffset = planchetteTransformY + offsetY

            // Move location of the magnifying glass
            const xMag = xMoveWithOffset * planchetteWidth / magSize
            const yMag = yMoveWithOffset * planchetteHeight / magSize
            mag.style.transform = `translateX(${xMag}%) translateY(${yMag}%)`;

            // Move background image inside magnifying glass (using pixels because I couldn't get % to work, this is why we have to call this method inside resizeUpdates)
            const xBgPosPx = -(xMoveWithOffset * planchetteWidth + MAG_LEFT * 100 * boardWidth) / 100 * MAG_ZOOM - magSize * MAG_ZOOM * (1 - 1 / MAG_ZOOM) / 2
            const yBgPosPx = -(yMoveWithOffset * planchetteHeight + MAG_TOP * 100 * boardHeight) / 100 * MAG_ZOOM - magSize * MAG_ZOOM * (1 - 1 / MAG_ZOOM) / 2
            mag.style.backgroundPosition = `${xBgPosPx}px ${yBgPosPx}px`
        }

        const updatePlanchettePosition = function () {
            const planchette = document.getElementById('planchette')
            const planchetteHelper = document.getElementById('planchetteHelper')

            planchette.style.transform = `translateX(${planchetteTransformX + offsetX}%) translateY(${planchetteTransformY + offsetY}%) rotate(130deg)`;
            planchetteHelper.style.transform = `translateX(${planchetteTransformX}%) translateY(${planchetteTransformY}%) rotate(130deg)`;
            updateMagnifyingGlassPosition()
        }

        const spiritGuidanceToOffset = function (x, y, diffX, diffY, goalX, goalY, dist) {
            const accelDistanceMultiplier = (SPIRIT_MAX_DIST - dist) / SPIRIT_MAX_DIST
            if (Math.random() > SPIRIT_STOCHASTIC_STR) {
                return
            }
            // TODO kokeile vaihtoehtosta kiihdytysta missa on vaan 1 paatos et kiihdytetaanko/hidastetaanko MAALIN SUUNTAISESTI (seka x etta y akseleilla) 
            if (diffX != 0 && Math.sign(goalX - x) == Math.sign(diffX)) { // X axis move is in preferable direction
                if (dist > 5) { // reduce jittery accels on top of goal
                    offsetX += diffX * SPIRIT_ACCEL_STR * 1.1 * 100.0 / planchetteWidth // accelerate
                }
            } else if (diffX != 0) { // X axis move is in undesired direction
                if (dist < 10) { // sharp cutoff for deceleration to reinforce feeling of "magnetic force" and to reduce unnecessary offsetting
                    offsetX -= diffX * SPIRIT_ACCEL_STR * accelDistanceMultiplier * 100.0 / planchetteWidth // decelerate
                }
            }
            if (diffY != 0 && Math.sign(goalY - y) == Math.sign(diffY)) { // Y axis move is in preferable direction
                if (dist > 5) {
                    offsetY += diffY * SPIRIT_ACCEL_STR * 1.1 * 100.0 / planchetteHeight // accelerate
                }
            } else if (diffY != 0) {
                if (dist < 10) {
                    offsetY -= diffY * SPIRIT_ACCEL_STR * accelDistanceMultiplier * 100.0 / planchetteHeight // decelerate
                }
            }
        }

        const cancelSomeOffset = function (diffX, diffY, urgency) {
            // Will accelerate or decelerate latest mouse move in an effort to reduce offset
            const e = OFFSET_CANCELLATION_STR * urgency
            if (Math.abs(offsetX) > 1) {
                const sign = (Math.sign(offsetX) == Math.sign(diffX) ? -1 : 1) // Decelerate or accelerate depending on sign
                offsetX += sign * diffX * e
                if (!draggingPlanchette) {
                    // When planchette is not being dragged, we need to do this to "negate" the effect on planchette position
                    planchetteTransformX -= sign * diffX * e
                }
            }
            if (Math.abs(offsetY) > 1) {
                const sign = (Math.sign(offsetY) == Math.sign(diffY) ? -1 : 1)
                offsetY += sign * diffY * e
                if (!draggingPlanchette) {
                    planchetteTransformY -= sign * diffY * e
                }
            }
        }

        const mouseMoved = function (event, onObject) {
            const currX = event.clientX
            const currY = event.clientY
            const diffX = (userMoveCount > 0 ? currX - prevX : 0)
            const diffY = (userMoveCount > 0 ? currY - prevY : 0)
            prevX = currX
            prevY = currY
            userMoveCount += 1

            if (draggingPlanchette) {
                const x = planchetteTransformX + offsetX + diffX * 100.0 / planchetteWidth
                const y = planchetteTransformY + offsetY + diffY * 100.0 / planchetteHeight
                if (y > HARD_Y_MAX || y < HARD_Y_MIN || x > HARD_X_MAX || x < HARD_X_MIN) {
                    // Prevent planchette from being moved outside board
                    stopDraggingPlanchette(event)
                    return
                }
                planchetteTransformX += diffX * 100.0 / planchetteWidth
                planchetteTransformY += diffY * 100.0 / planchetteHeight

                const goalX = remainingGoals.length > 0 ? goalCoords[remainingGoals[0]].x : -10000
                const goalY = remainingGoals.length > 0 ? goalCoords[remainingGoals[0]].y : -10000

                // Possibly accelerate/decelerate move by modifying cursor offset
                const dist = Math.sqrt((x - goalX) * (x - goalX) + (y - goalY) * (y - goalY))
                if (dist < SPIRIT_MAX_DIST) {
                    // Modify cursor offset to guide the user towards goal
                    // TODO Even if we are dragging we sometimes have to reduce offset to prevent the real cursor from escaping window.
                    spiritGuidanceToOffset(x, y, diffX, diffY, goalX, goalY, dist)
                } else {
                    // User dragging planchette but is not near goal, use this opportunity to
                    // reduce cursor offset to prevent the real cursor from escaping window.
                    if (y < SOFT_Y_MAX && y > SOFT_Y_MIN && x < SOFT_X_MAX && x > SOFT_X_MIN) {
                        // Soft limits are used to prevent us from accelerating the user beyond hard limits where planchette would be trapped
                        cancelSomeOffset(diffX, diffY, OFFSET_CANCELLATION_LOW_URGENCY)
                    }
                }
            } else {
                // User is not dragging planchette, use this opportunity to reduce cursor offset to prevent the real cursor from escaping window.
                const x = (currX + offsetX) / windowWidth
                const y = (currY + offsetY) / windowHeight
                const minimumEscapeDistance = Math.min(Math.abs(x - 0), Math.abs(x - 1), Math.abs(y - 1), Math.abs(y - 0))
                // TODO instead of linear we need to have exponential urgency towards the edges of window
                const urgency = Math.max(1 - minimumEscapeDistance / 0.30, OFFSET_CANCELLATION_LOW_URGENCY)
                cancelSomeOffset(diffX, diffY, urgency)
            }
            updatePlanchettePosition()

            const chooseCursorIcon = function () {
                if (draggingPlanchette) return 'assets/grabbing.cur'
                if (onObject === ON_PLANCHETTE && turn === TURN_SPIRIT) return 'assets/grab.cur'
                if (onObject === ON_BUTTON && waitingForConsent) return 'assets/aero_link.cur'
                return 'assets/aero_arrow.cur'
            }

            const cursor = document.getElementById("cursor")
            const newCursorSrc = chooseCursorIcon()
            if (cursor.src !== newCursorSrc) cursor.src = newCursorSrc
            cursor.style.visibility = "visible";
            paintCursorWithOffset(cursor, prevX, prevY)
        }

        const startDraggingPlanchette = function (event) {
            if (turn === TURN_SPIRIT) {
                draggingPlanchette = true
                cursor.src = "assets/grabbing.cur"
            }
        }
        const stopDraggingPlanchette = function (event, source) {
            draggingPlanchette = false
            const newCursor = (source === ON_PLANCHETTE ? 'assets/grab.cur' : 'assets/aero_arrow.cur')
            cursor.src = newCursor
            const x = planchetteTransformX + offsetX
            const y = planchetteTransformY + offsetY
            if (source === ON_PLANCHETTE) {
                if (debug[RECORDING]) {
                    const chars = ALLOWED_CHARS
                    let i = 0
                    while (debug[RECORDING][chars[i]]) i++
                    debug[RECORDING][chars[i]] = {
                        x: Math.round(100 * x) / 100,
                        y: Math.round(100 * y) / 100,
                    }
                    console.log(debug[RECORDING])
                } else {
                    // What is the closest character to planchette
                    let closestDist = 99999999
                    let closestChar = 'a'
                    for (let i = 0; i < ALLOWED_CHARS.length; i++) {
                        const char = ALLOWED_CHARS[i]
                        const c = goalCoords[char]
                        const dist = Math.sqrt((x - c.x) * (x - c.x) + (y - c.y) * (y - c.y))
                        if (dist < closestDist) {
                            closestDist = dist
                            closestChar = char
                        }
                    }
                    if (closestDist < CHAR_SELECT_MAX_DIST) {
                        // Close enough, interpret that user intends to select this character
                        if (remainingGoals.length > 0 && closestChar === remainingGoals[0]) {
                            // Selected character was goal, move onto the next goal.
                            addCharToRevealedMessage(closestChar)
                            remainingGoals = remainingGoals.substring(1)
                            if (remainingGoals.length === 0) {
                                log('Spirit: ' + spiritMessage.toUpperCase())
                                document.getElementById('planchette').classList = ['unselectable planchette-no-glow']
                                document.getElementById('userMessagePre').classList = ['unselectable blinking-caret']
                                document.getElementById('userMessagePre').innerText = ''
                                turn = TURN_USER
                                currentExchangeNumber++
                            }
                        }
                    }
                }
            }
            event.stopPropagation()
        }

        const addCharToRevealedMessage = function (char) {
            spiritMessage += char
            const container = document.getElementById('spiritMessageContainer')
            container.innerText = spiritMessage
            container.setAttribute('data-text', spiritMessage)
        }

        const switchTurnToSpirit = function () {
            turn = TURN_SPIRIT

            // Clear previously revealed spirit message
            spiritMessage = ''

            // Indicate to user that planchette can be dragged
            document.getElementById('planchette').classList = ['unselectable planchette-active-glow']

            // Clear previously revealed answer from visuals
            const container = document.getElementById('spiritMessageContainer')
            container.innerText = ''
            container.setAttribute('data-text', '')

            // Stop blinking caret
            document.getElementById('userMessagePre').classList = ['unselectable orangey-text']
        }

        const spiritIsReadyToCommunicate = function (rawMessage) {
            const message = rawMessage.toLocaleLowerCase().replace(/[^0-9a-z]/gi, '')
            const container = document.getElementById('spiritMessageContainer')

            logToSumoLogic(previousInput + " -> " + message)

            if (debug[SPEEDMODE]) {
                turn = TURN_USER
                spiritMessage = message
                console.log('Spirit: ' + spiritMessage.toUpperCase())
                container.innerText = message
                container.setAttribute('data-text', message)
                document.getElementById('userMessagePre').innerText = ''
                document.getElementById('userMessagePre').classList = ['unselectable blinking-caret']
                document.getElementById('planchette').classList = ['unselectable planchette-no-glow']
                currentExchangeNumber++
                return
            }
            remainingGoals = message // Set incoming message as new goals
        }

        const waitForConsent = function () {
            waitingForConsent = true
            document.getElementById('board').style.filter = `blur(10px) brightness(0.6)`;
            document.getElementById('planchetteHelper').style.filter = `blur(10px) brightness(0.6)`;
            document.getElementById('userMessageContainer').style.visibility = `hidden`;
            document.getElementById('consentPopup').style.display = `block`;
        }

        const mouseCheck = function () {
            if (userMoveCount < 20) {
                document.getElementById('mouseRequirement').style.color = 'red'
                return false
            }
            return true
        }

        const consentYes = function () {
            if (!mouseCheck()) return
            waitingForConsent = false
            window.localStorage.setItem(OUIJA_USER_ID, 'user' + Math.round(1000000000 * Math.random()))
            document.getElementById('consentPopup').style.opacity = '0'
            setTimeout(() => document.getElementById('consentPopup').style.display = 'none', 3000)
            document.getElementById('board').style.filter = `none`;
            document.getElementById('planchetteHelper').style.filter = `none`;
            document.getElementById('userMessageContainer').style.visibility = `visible`;
            document.getElementById('consentYes').classList.add(['one-time-bump'])
            const elementsToFadeOut = document.getElementsByClassName('popupText')
            for (let i = 0; i < elementsToFadeOut.length; i++) {
                elementsToFadeOut[i].style.opacity = '0.4';
            }
            document.getElementById('changingPopupText').innerText = 'Thank you for complying. We shall come for your soul after death.'
        }

        const consentNo = function () {
            if (!mouseCheck()) return
            const shiftXbuttonWidth = document.getElementById('consentNo').getBoundingClientRect().width * 100.0 / planchetteWidth
            const shiftXmarginWidth = windowWidth * 1.5 / planchetteWidth
            const shiftX = shiftXbuttonWidth + shiftXmarginWidth
            offsetX -= shiftX // Shift mouse to consentYes button
            planchetteTransformX += shiftX // Negate any effect on planchette's position
            const cursor = document.getElementById("cursor")
            paintCursorWithOffset(cursor, prevX, prevY)
            consentYes()
        }

    </script>
</head>

<body>

    <!-- Background element for mousemove events -->
    <div id="bg" class="unselectable"></div>

    <!-- Warning: dont move elements outside boardContainer, otherwise browser resizing will cause inconsistencies in positioning! -->
    <div id="boardContainer" class="unselectable">

        <!-- Board visual -->
        <img id="board" class="unselectable" src="assets/ouija_bg.jpg"></img>

        <!-- Fix edge case where mousemove events aren't captured on board's rounded corners -->
        <div id="hoverBoard" class="unselectable"></div>

        <!-- Planchette is visible and moves according to fake cursor, planchetteHelper is invisible and moves according to real cursor -->
        <img id="planchette" class="unselectable planchette-no-glow" src="assets/planchette2.png"></img>
        <img id="planchetteHelper" class="unselectable" src="assets/planchette2.png"></img>

        <!-- Magnifying glass -->
        <div id="magnifying-glass" class="unselectable">
            <div id="magnifying-glass-surface"></div>
        </div>

        <!-- Spirit message -->
        <div id="spiritMessageContainer" class="unselectable" data-text=""></div>

        <!-- User message -->
        <div id="userMessageContainer" class="unselectable">
            <pre id="userMessagePre" class="unselectable blinking-caret"></pre>
        </div>

        <!-- Pop-up for first-time visitors -->
        <div id="consentPopup" class="unselectable">
            <p class="popupText">Welcome, friend.</p>
            <ul class="popupText">
                <li>This website provides a horror experience. It is akin to a magic show; no actual spirits are
                    involved.
                </li>
                <li>Your conversations with spirits are recorded for development purposes, so do not divulge any
                    sensitive
                    information.</li>
                <li id="mouseRequirement">The experience requires a mouse. Please use your mouse to proceed.</li>
            </ul>
            <p id="changingPopupText">Would you like to offer your soul to support this website?</p>
            <div id="consentHoverboard" class="unselectable"></div>
            <div id="consentButtonsContainer">
                <div id="consentYes">Consent to selling your soul</div>
                <div id="consentNo">Enter without selling your soul</div>
            </div>
        </div>

        <!-- Preload cursor icons like this -->
        <img src="assets/aero_arrow.cur" style="visibility: hidden; position: absolute; pointer-events: none;" />
        <img src="assets/aero_link.cur" style="visibility: hidden; position: absolute; pointer-events: none;" />
        <img src="assets/grab.cur" style="visibility: hidden; position: absolute; pointer-events: none;" />
        <img src="assets/grabbing.cur" style="visibility: hidden; position: absolute; pointer-events: none;" />
        <img src="assets/beam_i.cur" style="visibility: hidden; position: absolute; pointer-events: none;" />

        <!-- Displayed cursor whose src is altered as needed -->
        <img src="assets/aero_arrow.cur" id="cursor" />
    </div>



    <noscript>
        <h1>This website requires JavaScript in order to do a trick. Please enable JavaScript and refresh.</h1>
    </noscript>

    <div id="mobileWarning">
        <h1>
            Your device is not supported, sorry. Can you come back on a desktop/laptop? You need a mouse and at least
            1200 pixels wide screen.
        </h1>
    </div>

    <script>

        // Mouse move events
        document.getElementById('bg').addEventListener('mousemove', e => { mouseMoved(e) })
        document.getElementById('hoverBoard').addEventListener('mousemove', e => { mouseMoved(e) })
        document.getElementById('planchette').addEventListener('mousemove', e => { mouseMoved(e) })
        document.getElementById('planchetteHelper').addEventListener('mousemove', e => { mouseMoved(e, ON_PLANCHETTE) })
        document.getElementById('consentHoverboard').addEventListener('mousemove', e => { mouseMoved(e) })
        document.getElementById('consentYes').addEventListener('mousemove', e => { mouseMoved(e, ON_BUTTON) })
        document.getElementById('consentNo').addEventListener('mousemove', e => { mouseMoved(e, ON_BUTTON) })

        // Consent click events
        document.getElementById('consentYes').addEventListener('click', e => { consentYes() })
        document.getElementById('consentNo').addEventListener('click', e => { consentNo() })

        // Activating planchetteDragging
        document.getElementById('planchetteHelper').addEventListener('mousedown', e => { startDraggingPlanchette(e) })

        // Deactivating planchetteDragging
        document.getElementById('planchetteHelper').addEventListener('mouseup', e => { stopDraggingPlanchette(e, ON_PLANCHETTE) })
        document.body.addEventListener('mouseup', e => { stopDraggingPlanchette(e) })
        document.body.addEventListener('mouseleave', e => {
            stopDraggingPlanchette(e)
            document.getElementById("cursor").style.visibility = "hidden"

            // Hopefully we dont have offsets when escaping window, but if we do, clear offsets
            if (offsetX != 0) {
                planchetteTransformX += offsetX // This negates any effect on planchette positioning
                offsetX = 0
            }
            if (offsetY != 0) {
                planchetteTransformY += offsetY
                offsetY = 0
            }
            updatePlanchettePosition()
        })

        // Keydown events
        document.body.addEventListener('keydown', e => {
            const lowerCasedChar = e.key.toLocaleLowerCase()
            if (turn === TURN_USER && !waitingForConsent) {
                const m = document.getElementById('userMessagePre')
                if (ALLOWED_CHARS.includes(lowerCasedChar) || lowerCasedChar == ' ') {
                    if (m.innerText.length < USER_MESSAGE_MAX_LENGTH) {
                        m.innerText += lowerCasedChar.toUpperCase()
                    }
                } else if (e.key == 'Enter') {
                    if (m.innerText.length >= 2) {
                        const userQuestion = m.innerText
                        console.log('Player: ' + userQuestion)
                        switchTurnToSpirit()
                        dispatchToSpirit(userQuestion, spiritIsReadyToCommunicate)
                    }
                } else if (e.key == 'Backspace' && m.innerText.length > 0) {
                    m.innerText = m.innerText.substring(0, m.innerText.length - 1)
                }
            }

            // Helpers for debugging
            if (!window.location.href.endsWith("#debug")) {
                return
            }
            if (e.key == "-") {
                if (document.getElementById('bg').style.cursor != 'none') {
                    document.getElementById('planchetteHelper').style.opacity = 0
                    document.getElementById('bg').style.cursor = 'none'
                    document.getElementById('hoverBoard').style.cursor = 'none'
                    document.getElementById('planchette').style.cursor = 'none'
                    document.getElementById('planchetteHelper').style.cursor = 'none'

                } else {
                    document.getElementById('planchetteHelper').style.opacity = 0.5
                    document.getElementById('bg').style.cursor = 'auto'
                    document.getElementById('hoverBoard').style.cursor = 'auto'
                    document.getElementById('planchette').style.cursor = 'auto'
                    document.getElementById('planchetteHelper').style.cursor = 'auto'
                }
            }
            if (e.key == "=") {
                debug[RECORDING] = {}
                console.log('Recording')
            }
            if (e.key == "/") {
                debug[SPEEDMODE] = true
            }
        })

        const cleanText = function (rawText) {
            const lowerCased = rawText.toLocaleLowerCase()
            let filtered = ''
            for (let i = 0; i < lowerCased.length; i++) {
                if (ALLOWED_CHARS.includes(lowerCased[i])) {
                    filtered += lowerCased[i]
                }
            }
            return filtered
        }

        if (!window.localStorage.getItem(OUIJA_USER_ID)) {
            waitForConsent()
        }

        if (window.innerWidth < 1200) {
            document.getElementById('mobileWarning').style.display = 'block';
        }

        // fetch('http://ip-api.com/json')
        //     .then(res => res.json())
        //     .then(response => {
        //         console.log("City: ", response.city);
        //     })
        //     .catch((data, status) => {
        //         console.log('Request failed');
        //     })

    </script>

    <script async src="chatbot.js"></script>

    <!--     <audio autoplay controls>
        <source src="assets/dk-atmosphere.mp3" type="audio/mpeg">
    </audio> -->



    <script defer data-domain="ouija.attejuvonen.fi" src="https://plausible.io/js/plausible.js"></script>

    <!-- <iframe width="361" height="25" src="https://www.youtube.com/embed/F0Jk80wDw2w" title="YouTube video player"
        frameborder="0" allowfullscreen="false"
        allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"></iframe> -->

</body>

</html>