<html>

<head>
    <title>Ouija Online - A horror experience</title>
    <style>
        * {
            box-sizing: border-box;
        }

        @keyframes glow {
            0% {
                box-shadow: 0 0 50px #d35400;
            }

            100% {
                box-shadow: 0 0 50px 20px #d35400;
            }
        }

        #boardContainer {
            position: absolute;
            width: 50%;
            left: 50%;
            top: 50%;
            -webkit-transform: translate(-50%, -50%);
            transform: translate(-50%, -50%);
        }

        #board {
            width: 100%;
            border-radius: 10%;
            z-index: 10;
            animation-name: glow;
            animation-iteration-count: infinite;
            animation-duration: 2s;
            animation-timing-function: ease-in-out;
            animation-direction: alternate;
        }

        #planchette,
        #planchetteHelper {
            position: absolute;
            top: 44%;
            left: 40.5%;
            width: 18%;
            transform: rotate(130deg);
        }

        #planchette {
            z-index: 15;
            -webkit-filter: drop-shadow(5px 5px 5px #222);
            filter: drop-shadow(5px 5px 5px #222);
        }

        #planchetteHelper {
            z-index: 16;
            opacity: 0;
            /* Can't use visibility:hidden because need mouse movements to trigger events */
        }

        #magnifying-glass {
            background-image: url('assets/ouija_bg.jpg');
            background-repeat: no-repeat;
            position: absolute;
            border-radius: 50%;
            cursor: none;
            visibility: hidden;
            z-index: 14;
        }

        #magnifying-glass-surface {
            background-color: #563e23;
            opacity: 0.4;
            width: 100%;
            height: 100%;
        }

        #cursor {
            position: absolute;
            top: 30%;
            left: 30%;
            height: 32px;
            /* height must be evenly divisible from 128px */
            visibility: hidden;
            pointer-events: none;
            z-index: 1000;
        }

        body {
            overflow-y: hidden;
            overflow-x: hidden;
            margin: 0;
            padding: 0;
            background: black;
            cursor: none;
        }

        .unselectable {
            user-select: none;
            -moz-user-select: none;
            -khtml-user-select: none;
            -webkit-user-select: none;
            -o-user-select: none;
            -ms-user-select: none;

            user-drag: none;
            -webkit-user-drag: none;
        }

        @media only screen and (max-width: 760px) {
            .button {
                display: none;
            }

            .mobile-warning {
                display: block;
            }
        }
    </style>

    <script>

        // Global state
        let draggingPlanchette = false
        let planchetteTransformX = 0 // In % relative to planchette's own width (to support browser resizing)
        let planchetteTransformY = 0 // In % relative to planchette's own width (to support browser resizing)
        let prevX = undefined
        let prevY = undefined
        let offsetX = 0 // In % relative to window planchette's width (to support browser resizing consistently with planchetteHelper)
        let offsetY = 0 // In % relative to window planchette's width (to support browser resizing consistently with planchetteHelper)
        let userMoveCount = 0
        let debug = {}

        // String literals
        const ON_PLANCHETTE = 'onPlanchette'

        // Magnifier constants
        const MAG_ZOOM = 1.2
        const MAG_LEFT = 0.465
        const MAG_TOP = 0.58

        // Offset constants
        const SPIRIT_MAX_DIST = 50.0
        const SPIRIT_STOCHASTIC_STR = 0.7
        const SPIRIT_ACCEL_STR = 1.1
        const OFFSET_CANCELLATION_STR = 0.3
        const OFFSET_CANCELLATION_LOW_URGENCY = 0.3

        // Planchette drag limitations (board area)
        const HARD_Y_MAX = 80
        const HARD_Y_MIN = -160
        const HARD_X_MAX = 270
        const HARD_X_MIN = -255
        const SOFT_Y_MAX = HARD_Y_MAX - 10
        const SOFT_Y_MIN = HARD_Y_MIN - 10
        const SOFT_X_MAX = HARD_X_MAX - 10
        const SOFT_X_MIN = HARD_X_MIN - 10

        // Memoize some values to reduce reflows (improve performance).
        let boardWidth = 0
        let boardHeight = 0
        let boardTop = 0
        let boardLeft = 0
        let planchetteWidth = 0
        let planchetteHeight = 0
        let magSize = 0
        let windowWidth = 0
        let windowHeight = 0
        const resizeUpdates = function () {
            // Update memoized values
            const boardBounds = document.getElementById('boardContainer').getBoundingClientRect()
            boardTop = boardBounds.top
            boardLeft = boardBounds.left
            boardWidth = boardBounds.width
            boardHeight = boardBounds.height
            const planchette = document.getElementById('planchette')
            planchetteWidth = planchette.clientWidth
            planchetteHeight = planchette.clientHeight
            windowWidth = window.innerWidth
            windowHeight = window.innerHeight

            // Update magnifying glass
            const mag = document.getElementById('magnifying-glass')
            magSize = planchetteWidth * 0.40
            Object.assign(mag.style, {
                left: (100 * MAG_LEFT) + "%",
                top: (100 * MAG_TOP) + "%",
                width: magSize + 'px', // TODO %
                height: magSize + 'px', // TODO %
                backgroundSize: (MAG_ZOOM * 100 * boardWidth / magSize) + '% ' + (MAG_ZOOM * 100 * boardHeight / magSize) + '%',
                visibility: 'visible'
            })
            updateMagnifyingGlassPosition()

            // Fix edge case where user sees 2 cursors when using keyboard shortcut to resize browser
            cursor.style.visibility = "hidden";
        }
        // Call resizeUpdates after the first complete render and after each resize
        window.addEventListener('load', function (event) {
            resizeUpdates()
        });
        window.addEventListener('resize', function (event) {
            resizeUpdates()
        });

        const paintCursorWithOffset = function (cursor, realX, realY) {
            let x = realX + offsetX * planchetteWidth / 100
            let y = realY + offsetY * planchetteHeight / 100

            // Never paint cursor outside partially outside viewport
            if (x > windowWidth - 24) {
                x = Math.max(realX, windowWidth - 24)
            }
            if (y > windowHeight - 24) {
                y = Math.max(realY, windowHeight - 24)
            }
            if (x < 0) {
                x = 0
            }
            if (y < 0) {
                y = 0
            }

            cursor.style.top = (y - boardTop) + "px";
            cursor.style.left = (x - boardLeft) + "px";
        }

        const updateMagnifyingGlassPosition = function () {
            const mag = document.getElementById('magnifying-glass')
            const xMoveWithOffset = planchetteTransformX + offsetX
            const yMoveWithOffset = planchetteTransformY + offsetY

            // Move location of the magnifying glass
            const xMag = xMoveWithOffset * planchetteWidth / magSize
            const yMag = yMoveWithOffset * planchetteHeight / magSize
            mag.style.transform = `translateX(${xMag}%) translateY(${yMag}%)`;

            // Move background image inside magnifying glass (using pixels because couldn't get % to work, this is why we have to call this method inside resizeUpdates)
            const xBgPosPx = -(xMoveWithOffset * planchetteWidth + MAG_LEFT * 100 * boardWidth) / 100 * MAG_ZOOM - magSize * MAG_ZOOM * (1 - 1 / MAG_ZOOM) / 2
            const yBgPosPx = -(yMoveWithOffset * planchetteHeight + MAG_TOP * 100 * boardHeight) / 100 * MAG_ZOOM - magSize * MAG_ZOOM * (1 - 1 / MAG_ZOOM) / 2
            mag.style.backgroundPosition = `${xBgPosPx}px ${yBgPosPx}px`
        }

        const updatePlanchettePosition = function () {
            const planchette = document.getElementById('planchette')
            const planchetteHelper = document.getElementById('planchetteHelper')

            planchette.style.transform = `translateX(${planchetteTransformX + offsetX}%) translateY(${planchetteTransformY + offsetY}%) rotate(130deg)`;
            planchetteHelper.style.transform = `translateX(${planchetteTransformX}%) translateY(${planchetteTransformY}%) rotate(130deg)`;
            updateMagnifyingGlassPosition()
        }

        const spiritGuidanceToOffset = function (x, y, diffX, diffY, goalX, goalY, dist) {
            const accelDistanceMultiplier = (SPIRIT_MAX_DIST - dist) / SPIRIT_MAX_DIST
            if (Math.random() > SPIRIT_STOCHASTIC_STR) {
                return
            }
            if (diffX != 0 && Math.sign(goalX - x) == Math.sign(diffX)) { // X axis move is in preferable direction
                if (dist > 5) { // reduce jittery accels on top of goal
                    offsetX += diffX * SPIRIT_ACCEL_STR * 1 * 100.0 / planchetteWidth // accelerate
                }
            } else if (diffX != 0) { // X axis move is in undesired direction
                if (dist < 10) { // sharp cutoff for deceleration to reinforce feeling of "magnetic force" and to reduce unnecessary offsetting
                    offsetX -= diffX * SPIRIT_ACCEL_STR * accelDistanceMultiplier * 100.0 / planchetteWidth // decelerate
                }
            }
            if (diffY != 0 && Math.sign(goalY - y) == Math.sign(diffY)) { // Y axis move is in preferable direction
                if (dist > 5) {
                    offsetY += diffY * SPIRIT_ACCEL_STR * 1 * 100.0 / planchetteHeight // accelerate
                }
            } else if (diffY != 0) {
                if (dist < 10) {
                    offsetY -= diffY * SPIRIT_ACCEL_STR * accelDistanceMultiplier * 100.0 / planchetteHeight // decelerate
                }
            }
        }

        const cancelSomeOffset = function (diffX, diffY, urgency) {
            // Will accelerate or decelerate latest mouse move in an effort to reduce offset
            const e = OFFSET_CANCELLATION_STR * urgency
            if (Math.abs(offsetX) > 1) {
                const sign = (Math.sign(offsetX) == Math.sign(diffX) ? -1 : 1) // Decelerate or accelerate depending on sign
                offsetX += sign * diffX * e
                if (!draggingPlanchette) {
                    // When planchette is not being dragged, we need to do this to "negate" the effect on planchette position
                    planchetteTransformX -= sign * diffX * e
                }
            }
            if (Math.abs(offsetY) > 1) {
                const sign = (Math.sign(offsetY) == Math.sign(diffY) ? -1 : 1)
                offsetY += sign * diffY * e
                if (!draggingPlanchette) {
                    planchetteTransformY -= sign * diffY * e
                }
            }
        }

        const mouseMoved = function (event, onPlanchette) {
            const currX = event.clientX
            const currY = event.clientY
            const diffX = (userMoveCount > 0 ? currX - prevX : 0)
            const diffY = (userMoveCount > 0 ? currY - prevY : 0)
            prevX = currX
            prevY = currY
            userMoveCount += 1

            if (draggingPlanchette) {
                const x = planchetteTransformX + offsetX + diffX * 100.0 / planchetteWidth
                const y = planchetteTransformY + offsetY + diffY * 100.0 / planchetteHeight
                if (y > HARD_Y_MAX || y < HARD_Y_MIN || x > HARD_X_MAX || x < HARD_X_MIN) {
                    // Prevent planchette from being moved outside board
                    stopDraggingPlanchette(event)
                    return
                }
                planchetteTransformX += diffX * 100.0 / planchetteWidth
                planchetteTransformY += diffY * 100.0 / planchetteHeight

                const goalX = -7
                const goalY = -117

                // Possibly accelerate/decelerate move by modifying cursor offset
                const dist = Math.sqrt((x - goalX) * (x - goalX) + (y - goalY) * (y - goalY))
                if (dist < SPIRIT_MAX_DIST) {
                    // Modify cursor offset to guide the user towards goal
                    // TODO Even if we are dragging we sometimes have to reduce offset to prevent the real cursor from escaping window.
                    spiritGuidanceToOffset(x, y, diffX, diffY, goalX, goalY, dist)
                } else {
                    // User is not near goal, use this opportunity to reduce cursor offset to prevent the real cursor from escaping window.
                    if (y < SOFT_Y_MAX && y > SOFT_Y_MIN && x < SOFT_X_MAX && x > SOFT_X_MIN) {
                        // Soft limits are used to prevent us from accelerating the user beyond hard limits where planchette would be trapped
                        cancelSomeOffset(diffX, diffY, OFFSET_CANCELLATION_LOW_URGENCY)
                    }
                }
            } else {
                // User is not dragging planchette, use this opportunity to reduce cursor offset to prevent the real cursor from escaping window.
                const x = (currX + offsetX) / windowWidth
                const y = (currY + offsetY) / windowHeight
                const minimumEscapeDistance = Math.min(Math.abs(x - 0), Math.abs(x - 1), Math.abs(y - 1), Math.abs(y - 0))
                // TODO instead of linear we need to have exponential urgency towards the edges of window
                const urgency = Math.max(1 - minimumEscapeDistance / 0.30, OFFSET_CANCELLATION_LOW_URGENCY)
                cancelSomeOffset(diffX, diffY, urgency)
            }
            updatePlanchettePosition()

            const cursor = document.getElementById("cursor")
            const newCursorSrc = (draggingPlanchette ? 'assets/grabbing.cur' : (onPlanchette === ON_PLANCHETTE ? 'assets/grab.cur' : 'assets/aero_arrow.cur'))
            if (cursor.src !== newCursorSrc) cursor.src = newCursorSrc
            cursor.style.visibility = "visible";
            paintCursorWithOffset(cursor, prevX, prevY)
        }

        const startDraggingPlanchette = function (event) {
            draggingPlanchette = true
            cursor.src = "assets/grabbing.cur"
        }
        const stopDraggingPlanchette = function (event, source) {
            draggingPlanchette = false
            const newCursor = (source === 'onPlanchette' ? 'assets/grab.cur' : 'assets/aero_arrow.cur')
            cursor.src = newCursor
            event.stopPropagation()
        }

    </script>
</head>

<body>

    <div id="bg" style="position: absolute; width: 100%; height: 100%"></div>

    <!-- Warning: dont move elements outside boardContainer, otherwise browser resizing will cause inconsistencies in positioning! -->
    <div id="boardContainer" class="unselectable">
        <img id="board" class="unselectable" src="assets/ouija_bg.jpg"></img>

        <!-- Planchette is visible and moves according to fake cursor, planchetteHelper is invisible and moves according to real cursor -->
        <img id="planchette" class="unselectable" src="assets/planchette2.png"></img>
        <img id="planchetteHelper" class="unselectable" src="assets/planchette2.png"></img>

        <!-- Magnifying glass -->
        <div id="magnifying-glass" class="unselectable">
            <div id="magnifying-glass-surface"></div>
        </div>

        <!-- Preload cursor icons like this -->
        <img src="assets/aero_arrow.cur" style="visibility: hidden; position: absolute;" />
        <img src="assets/aero_link.cur" style="visibility: hidden; position: absolute;" />
        <img src="assets/grab.cur" style="visibility: hidden; position: absolute;" />
        <img src="assets/grabbing.cur" style="visibility: hidden; position: absolute;" />

        <!-- Displayed cursor whose src is altered as needed -->
        <img src="assets/aero_arrow.cur" id="cursor" />
    </div>

    <noscript>
        <h1>This website requires JavaScript in order to do a trick. Please enable JavaScript and refresh.</h1>
    </noscript>

    <h1 class="mobile-warning" style="display: none;">
        This website requires a laptop/desktop device with a mouse, and a sufficiently large screen. Try with another
        device?
    </h1>

    <script>

        // Mouse move events
        document.getElementById('bg').addEventListener('mousemove', e => { mouseMoved(e) })
        document.getElementById('board').addEventListener('mousemove', e => { mouseMoved(e) })
        document.getElementById('planchette').addEventListener('mousemove', e => { mouseMoved(e) })
        document.getElementById('planchetteHelper').addEventListener('mousemove', e => { mouseMoved(e, ON_PLANCHETTE) })

        // Activating planchetteDragging
        document.getElementById('planchetteHelper').addEventListener('mousedown', e => { startDraggingPlanchette(e) })

        // Deactivating planchetteDragging
        document.getElementById('planchetteHelper').addEventListener('mouseup', e => { stopDraggingPlanchette(e, ON_PLANCHETTE) })
        document.body.addEventListener('mouseup', e => { stopDraggingPlanchette(e) })
        document.body.addEventListener('mouseleave', e => {
            stopDraggingPlanchette(e)
            console.log('mouseLeave event')
            document.getElementById("cursor").style.visibility = "hidden"

            // Hopefully we dont have offsets when escaping window, but if we do, clear offsets
            if (offsetX != 0) {
                planchetteTransformX += offsetX // This negates any effect on planchette positioning
                offsetX = 0
            }
            if (offsetY != 0) {
                planchetteTransformY += offsetY
                offsetY = 0
            }
            updatePlanchettePosition()
        })

        // Helpers for debugging
        document.body.addEventListener('keydown', e => {
            if (!window.location.href.endsWith("#debug")) {
                return
            }
            if (e.key == "d") {
                if (document.body.style.cursor != 'none') {
                    document.getElementById('planchetteHelper').style.opacity = 0
                    document.body.style.cursor = 'none'
                } else {
                    document.getElementById('planchetteHelper').style.opacity = 0.5
                    document.body.style.cursor = 'auto';
                }
            }
            if (e.key == "r") {
                debug['recording'] = {}
                console.log('Recording')
            }
        })

    </script>

    <script async data-domain="attejuvonen.fi" src="https://plausible.io/js/plausible.js"></script>

</body>

</html>